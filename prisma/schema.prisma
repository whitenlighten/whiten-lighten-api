// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum Role {
  SUPERADMIN
  ADMIN
  DOCTOR
  NURSE
  FRONTDESK
  PATIENT
}

enum PatientStatus {
  PENDING
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum NoteStatus {
  PENDING
  APPROVED
  REJECTED
}

enum InvoiceStatus {
  UNPAID
  PARTIALLY_PAID
  PAID
  CANCELLED
}

enum PaymentMethod {
  CASH
  INSURANCE
  HMO
  TRANSFER
  CARD
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum BloodGroup {
  A_POS
  A_NEG
  B_POS
  B_NEG
  AB_POS
  AB_NEG
  O_POS
  O_NEG
}

enum RegistrationType {
  SELF
  FRONTDESK
  ADMIN
  DOCTOR
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum MaritalStatus {
  SINGLE
  MARRIED
  DIVORCED
  WIDOWED
}



enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}


model Patient {
  id        String @id @default(cuid())
  patientId String @unique // System-generated e.g., "PAT-00001"

  // Identification
  firstName     String
  lastName      String
  middleName    String?
  gender        Gender?
  dateOfBirth   DateTime?
  age           Int? // Optional (can be derived)
  maritalStatus MaritalStatus?
  occupation    String?
  religion      String?
  bloodGroup    BloodGroup?
  genotype      String?

  // Contact Info
  phone           String @unique
  alternatePhone  String?
  email           String @unique
  address         String?
  state           String?
  lga             String?
  country        String? @default("Nigeria")

  // Emergency Contact
  emergencyName     String?
  emergencyPhone    String?
  emergencyRelation String?

  // Medical Info
  allergies           String?
  chronicConditions   String?
  pastMedicalHistory  String?
  pastSurgicalHistory String?
  currentMedications  String?
  immunizationRecords String?
  familyHistory       String?

  // Admin / System Info
  registrationType  RegistrationType @default(FRONTDESK)
  registeredById    String? // staff who registered patient
  registeredBy      User?            @relation("RegisteredPatients", fields: [registeredById], references: [id])
  insuranceProvider String?
  insuranceNumber   String?
  paymentMethod     PaymentMethod?
  primaryDoctorId   String? // linked to Doctor
  status            PatientStatus    @default(ACTIVE)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  approvedAt    DateTime?
  deletedAt    DateTime?
  createdById  String?
  approvedById User?    @relation(fields: [userId], references: [id])

  // Relations
  clinicalNotes ClinicalNote[]
  visits        Visit[]
  invoices      Invoice[]
  Appointment   Appointment[]
  userId        String?

  NoteSuggestion NoteSuggestion[]
}

/**
 * CLINICAL NOTE MODEL
 * Captures workflow: Nurse writes observation → Doctor approves
 */
model ClinicalNote {
  id String @id @default(cuid())

  patientId String
  patient   Patient @relation(fields: [patientId], references: [id])

  createdById String  // always a Doctor/Admin/Superadmin
  createdBy   User    @relation(fields: [createdById], references: [id])

  observations String?   // nurse's original input (copied from suggestion if applicable)
  doctorNotes  String?   // doctor’s additional notes/diagnosis
  treatmentPlan String?  // optional structured field
  status       NoteStatus @default(APPROVED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  visitId String?
  visit   Visit? @relation(fields: [visitId], references: [id])

  approvedById String?
  approvedBy   User? @relation("PatientApprovedBy", fields: [approvedById], references: [id])

  User User[] @relation("DoctorApprovedNotes")
}

/**
 * VISIT MODEL
 * Represents a patient visit (can be linked to appointments later)
 */
model Visit {
  id        String   @id @default(cuid())
  patientId String
  patient   Patient  @relation(fields: [patientId], references: [id])
  visitDate DateTime @default(now())
  reason    String?
  notes     String?

  ClinicalNote ClinicalNote[]
}

/**
 * INVOICE MODEL
 * Patient billing records
 */


model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password      String
  firstName     String?
  lastName      String?
  phone         String?
  role          Role
  specialization String?
  isActive      Boolean   @default(true)
  emailVerified Boolean   @default(false)

  // --- NEW FIELDS (for OAuth + 2FA) ---
  oauthProvider    String?   // e.g., "google"
  oauthId          String?   // provider-specific id
  twoFactorEnabled Boolean   @default(false)
  twoFactorSecret  String?   // base32 secret for authenticator app
  twoFactorTempSecret String?                     // ADDED (temporary during setup)


  lastLogin     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?

  // relation
  refreshTokens RefreshToken[]
  auditLogs     AuditLog[]     @relation("UserAuditLogs")
  patients      Patient[]      @relation("RegisteredPatients") // Patients registered by staff
  nurseNotes    NoteSuggestion[] @relation("NurseCreatedNotes") // Notes created as Nurse
  doctorNotes   ClinicalNote[] @relation("DoctorApprovedNotes") // Notes approved as Doctor
  Appointment   Appointment[]
  Patient       Patient[]
  createdClinicalNotes ClinicalNote[] @relation(fields: [], references: [])

  @@index([email])
  createdNoteSuggestions NoteSuggestion[] @relation("NoteSuggestionCreatedBy")
  approvedNoteSuggestions NoteSuggestion[] @relation("NoteSuggestionApprovedBy")
  ClinicalNote ClinicalNote[] @relation("PatientApprovedBy")
}

// New Model for Refresh Tokens
model RefreshToken {
  // We'll use the id as the token record identifier (jti)
  id        String   @id @default(uuid())
  token     String // store hashed token
  userId    String
  revoked   Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AuditLog {
  id         String   @id @default(uuid())
  userId     String?
  action     String
  resource   String
  resourceId String?
  changes    Json?
  createdAt  DateTime @default(now())

  user User? @relation("UserAuditLogs", fields: [userId], references: [id])
}

model Appointment {
  id         String            @id @default(uuid())
  patientId  String
  doctorId String? // doctor id
  date       DateTime
  status     AppointmentStatus @default(PENDING)
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  reason     String?
  service    String @default("General Consultation")

  patient  Patient @relation(fields: [patientId], references: [id])
  doctor User?   @relation(fields: [doctorId], references: [id])
}

model PatientCounter {
  id        Int      @id @default(1) // always one row
  value     Int      @default(0)
  updatedAt DateTime @updatedAt
}

model Invoice {
  id          String        @id @default(cuid())
  patientId   String
  patient     Patient       @relation(fields: [patientId], references: [id])
   amount      Float                        // total expected amount
  status      InvoiceStatus @default(UNPAID)

  // optional but useful for real systems
  currency    String        @default("NGN")
  description String?
  reference   String?       @unique       // e.g. "INV-2025-000123"
  dueDate     DateTime?
  metadata    Json?

  // timestamps
  issuedAt    DateTime      @default(now())
  paidAt      DateTime?
  updatedAt   DateTime      @updatedAt

  // RELATION (new)
  payments    Payment[]    // ← NEW: Link multiple payments (partial, retry, refund)
}

model Payment {
  id            String         @id @default(cuid())
  invoiceId     String
  invoice       Invoice        @relation(fields: [invoiceId], references: [id])

  amount        Float
  method        PaymentMethod              // reuse your existing enum
  status        PaymentStatus  @default(PENDING)

  // gateway/ops
  transactionRef String?       @unique
  gateway        String?       // e.g. "paystack", "flutterwave", "manual"
  note           String?

  createdAt     DateTime       @default(now())
  paidAt        DateTime?
}


model NoteSuggestion {
  id          String   @id @default(cuid())
  patientId   String
  patient     Patient  @relation(fields: [patientId], references: [id])

  createdById String   // nurse ID
  createdBy   User     @relation("NoteSuggestionCreatedBy", fields: [createdById], references: [id])

  content     String
  status      NoteStatus @default(PENDING)

  approvedById String?
  approvedBy   User?     @relation("NoteSuggestionApprovedBy", fields: [approvedById], references: [id])

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  User User[] @relation("NurseCreatedNotes")
}
